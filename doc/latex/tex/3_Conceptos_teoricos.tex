\capitulo{3}{Conceptos teóricos}

En esta sección se va proceder a la explicación de ciertos conceptos teóricos necesarios para la correcta compresión de este trabajo. Además, dichos conceptos han sido necesarios para llevar a cabo la toma decisiones sobre cómo resolver el trabajo junto con la realización del mismo.


\section{Web API}

Antes de hablar de que es un Web API tendremos que explicar que es un API, ya que la funcionalidad de un Web API es similar a la de un API, pero orientada a la Web.

\subsection{API}

Una posible definición podría ser la siguiente: \emph{Un API (siglas de Application Programming Interface) es un conjunto de subrutinas, funciones y procedimientos que ofrece cierta biblioteca para ser utilizado por otro software como una capa de abstracción.} \cite{wiki:api}.





Es decir, permite la comunicación entre distintos componentes software. La mayor ventaja es que permite reutilizar métodos escrito en un determinado lenguaje o software, de esta manera evitamos la existencia de duplicidad de una misma funcionalidad en los diferentes componentes. Además, estas funcionalidades se encuentran testeadas y funcionan de forma adecuada en un determinado componente software.

\subsection{Web API}

En este caso y relacionado con lo anteriormente explicado, la lógica de un Web API es la misma que un API salvo que en este caso esta comunicación, es decir, el intercambio de información se realiza entre un servicio web y una aplicación mediante una URL. Para llevar a cabo esta comunicación, se utilizan peticiones HTTP o HTTPS y toda esta información se encuentra encapsulada generalmente en XML o JSON.
Existen principalmente cuatro tipos de Web API.

\subsubsection{SOAP}

Es un protocolo estándar de intercambio de información y datos en XML entre dos objetos, cuyas siglas son: \emph{Simple Object Access Protocol}. \cite{wiki:soap} \cite{wiki:soap2}

\subsection{XML-RPC}

Es un protocolo que llama a un procedimiento remoto, que utiliza XML para encapsular los datos y llamadas HTTP para llevar a cabo la comunicación.

\subsubsection{JSON-RPC}

Es un protocolo cuya lógica es igual que el protocolo explicado anteriormente, salvo que en este caso utiliza el formato JSON para encapsular los datos.

\subsubsection{REST}

Es una arquitectura software para sistemas hipermedia en la World Wide Web. Además, esta arquitectura utiliza el protocolo HTTP para llevar a cabo la comunicación. No obstante, en esta misma sección se dedicará un apartado donde se profundizará más en este protocolo \cite{wiki:rest}. \ref{sec:Rest}


\section{LTI}\label{subsec:LTI}

\emph{Learning Tools Interoperability} es un estándar desarrollado por \emph{IMS Global Learning Consortium} que permite utilizar un framework o marco para la integración de aplicaciones educativas con un entorno de aprendizaje. \cite{wiki:lti}
Un ejemplo podría ser el siguiente:

\begin{itemize}
	\item \textbf{Entorno de aprendizaje} Moodle.
	\item \textbf{Marco:} LTI.
	\item \textbf{Aplicación educativa:} Proyecto de partida.
\end{itemize}

\subsection{Términos}

A continuación, se enumeran y describen los términos involucrados en el funcionamiento.

\begin{itemize}

	\item \textbf{Consumer:} este será el consumidor de aplicaciones y enviará la información necesaria al proveedor para realizar la comunicación entre ambas. Un ejemplo de consumer sería: \emph{Moodle o UbuVirtual.}
	
	\item \textbf{Provider:} este será el encargado de proporcionar la aplicación al consumidor. Para ello, será necesario establecer un canal de comunicación para que el consumidor le proporcione cierta información vital para su correcto funcionamiento. Un ejemplo de provider sería: el proyecto de partida, QuickTest.
	
	\item \textbf{Learning Management System:} es un software alojado en el servidor utilizado para realizar toda las tareas de gestión de las actividades de formación no presencial. Un ejemplo sería: \emph{Moodle o UbuVirtual.} \cite{wiki:lms}.
	
	\item \textbf{Consumer Key:} clave generada por el proveedor, la cual permite al consumidor identificar al proveedor autorizado cuando este realice peticiones al consumidor.
	
	\item \textbf{Shared secret:} clave o contraseña común al proveedor y consumidor.
	
	\item \textbf{Context:} conjunto de información proporcionada por el consumidor, al realizar una petición al proveedor. Un ejemplo sería: \emph{Click en una herramienta externa en Moodle}.
	
	\item \textbf{Resource link:} enlace asociado a un determinado recurso en el proveedor, al que el sistema nos redirecciona al seleccionar una herramienta externa en el consumidor.
	
\end{itemize}


\section{REST}\label{sec:Rest}

Como ya hemos explicado anteriormente, \emph{es un estilo de arquitectura software para sistemas hipermedia distribuidos como la World Wide Web} \cite{wiki:rest2}, cuyas siglas son las siguientes \textbf{REpresentational State Transfe}r o en castellano, Transferencia de Estado Representacional.

En la actualidad, el termino REST se utiliza para aquellas interfaces que utilicen HTTP para el intercambio de información entre sistemas, pudiendo utilizar cualquier formato para encapsular los datos, aunque generalmente los más utilizados son XML y JSON. Además, actualmente, los sistemas que siguen las pautas o principios REST también se les suelen denominar RESTful.
Para que un sistema se considere RESTful debe de cumplir con las siguientes pautas o principios. \cite{wiki:rest}

\begin{itemize}

	\item \textbf{Protocolo cliente/servidor sin estado:} de manera que cada petición HTTP debe contener toda aquella información necesaria para poder ejecutarse. De esta forma,  evitamos que tanto el cliente como el servidor tengan que almacenar información sobre el estado previo de la misma para poder llevarla a cabo.
	
	\item \textbf{Operaciones:} un sistema REST debe poder llevar cabo las siguientes operaciones: \emph{POST (crear), GET (leer o consultar), PUT (editar) y DELETE (borrar)}. Estas operaciones, como podemos observar, se asemejan en gran parte a las operaciones CRUD en bases de datos.
	
	\item \textbf{Sistema de capas:} el sistema deberá de utilizar una arquitectura jerárquica entre los distintos componentes que la formen, de esta manera, garantizamos que cada una de estas capas se encargue de llevar a cabo una única funcionalidad.
	
	\item \textbf{Manipulación de recursos:} para realizar la manipulación de los objetos se lleva a cabo mediante la URI. Dicha URI se utiliza como el identificador único para cada recurso, un recurso es un elemento de información. De esta manera se simplifica el acceso a la información para su posterior manipulación.
	
	\item \textbf{Uso de hipermedios:} para las transiciones entre los distintos estados de la aplicación y para la información de la misma.
	
\end{itemize}
 
